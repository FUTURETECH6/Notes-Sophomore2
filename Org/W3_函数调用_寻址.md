# 函数调用

## 样例1：Fact

**压栈**

```assembly
addi $sp, $sp, -8	# MIPS中没有subi
sw   $ra, 4($sp)	# 这样可以防止递归调用使地址丢失
sw   $a0, 8($sp)	# 寄存器传参
```

Caller主调函数、Callee被调函数

约定俗成

* `$s0-$s9`：子函数保持(视作硬盘，借给别人的时候要转存)
* `$to-$t9`：子函数不保存(视作u盘，随便搞)

再注意：栈从高到低

若是Fact()函数，Fact中递归的下一个指令的位置为2000，主程序中调用Fact的下个指令位置为1000，则栈为：

|                       | SP   |      | SP-8 |      | SP-16 |      |      |
| --------------------- | ---- | ---- | ---- | ---- | ----- | ---- | ---- |
| 主程序第一次call fact | 1000 | 2    |      |      |       |      |      |
| 第一次递归fact        | 1000 | 2    | 2000 | 1    |       |      |      |
| 第二次递归fact        | 1000 | 2    | 2000 | 1    | 2000  | 0    |      |
| n<1时                 | 1000 | 2    | 2000 | 1    |       |      |      |
|                       |      |      |      |      |       |      |      |

`jr rs(默认是$ra)`：PC ← rs并jmp：调到rs的位置

另外有个指针`$fp`表示栈底，平常用不到，但是可以多个栈的时候用到；或者要丢弃某块栈



## 样例2：strcpy

```assembly

```

清零：`addi $sp, $zero, $zero`



Make the common cast fast

传32位常数：32位指令只有16位给立即数

```assembly
lui  $t0, 12		# load upper immediate
addi $t0, $t0, 34	# 错的，若立即数是负的会把高位给影响了
ori  $to, $t0, 34	# 伪指令：`ulw $s0, 32bits`
```

Reserved reg for assembler: `$at`



# 跳

## j 绝对地址

一般是J型指令，但是有个`jar`是R型指令

| j     | {$location} |
| ----- | ----------- |
| 2     | 1000        |
| 6bits | 26bits      |

伪定向：为了让地址位能多几位：使用立即数的26位和PC的高4位，再x4(<<2)即可获得一个32位地址，所以除去来自PC的高4位实际上能定址的范围是256MB

## b 相对地址

| b    |      |      | {$offfset} |
| ---- | ---- | ---- | ---------- |
|      |      |      |            |
| 6    | 5    | 5    | 16bits     |

[(PC+4)](跳过当前行) + offset x 4

例

```assembly
	bne $, $, Exit	# 此处offset为8 Byte
	add ...
	j Loop
Exit:
```



# 寻址方式

* 立即数：自身的16位数作为操作数
* 寄存器：寄存器作为操作数
* 基址：`8($t0)`
* PC相对：branch：16位offset左移两位和(PC+4)**相加**
* 伪直接：jump：26位offset左移两位和PC的高四位**相连**



**R指令没有16位来存立即数，所以很富余，拿右边op6位+funct6位来存R指令的功能**

**寄存器**

* at
* gp：全局量堆
* ra：函数存PC
* `$v`：返回值
* `$a`：参数

