通过基类指针析构子类的不同反应，合理

```cpp
using namespace std;

struct Base {
    ~Base() { cout << "~Base()" << endl; }
};
struct Derived : public Base {
    ~Derived() { cout << "~Derived()" << endl; }
};

struct VirBase {
    virtual ~VirBase() { cout << "~VirBase()" << endl; }
};
struct VirDerived : public VirBase {
    virtual ~VirDerived() { cout << "~VirDerived()" << endl; }
};

int main(int argc, char const *argv[]) {
    Base *pBase       = new Derived();
    VirBase *pVirBase = new VirDerived();
    delete pBase;
    delete pVirBase;
    return 0;
}

/*
~Base()
~VirDerived()
~VirBase()
*/
```

自动构造的`=`运算符可以实现子类到基类的拷贝

```cpp
class Base {
  private:
    int a;

  public:
    void seta(int va) { a = va; }
    void showa() { cout << a << endl; }
};

class Derived : public Base {
  public:
    Derived() : Base() {}
    void foo(const Derived &rhs) { Base::operator=(rhs); }
};

int main(int argc, char const *argv[]) {
    Derived a, b;
    b.seta(99);
    a.foo(b);
    a.showa();
    return 0;
}

/*
99
*/
```

